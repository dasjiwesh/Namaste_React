Lecture: 1
Study about Emmet: https://www.youtube.com/watch?v=V8vizNQKtx0&t=528s
React came into existence as developers wanted to write HTML, CSS inside JS.
"npm init" is used for installing package.json file
npm i -D / --save/same(strange but works on my PC)-dev parcel for instaling parcel bundler where '-D' stands for devDependencies which is for development purpose not for production
"dependencies": {
    "parcel": "^2.8.3"
         ~version “Approximately equivalent to version”, will update you to all future patch versions, without incrementing the minor version. ~1.2.3 will use releases from 1.2.3 to <1.3.0.
                       ^version “Compatible with version”, will update you to all future minor/patch versions, without incrementing the major version. ^2.3.4 will use releases from 2.3.4 to < 3.0.0.
We need to Manify-Bundle-Chunking-TreeShaking in react for which we need dependencies
In package.json dependency version will update but package-lock.json will keep it according to the version of dependency we developed.It maintains even the hash. So production version will not be compromised.
package.json manages transitive dependencies
package-lock.json will push our code into Version Control System then VCS will push it in server then it'll be pushed to production.
In node_modules htmlparse module is for html parsing, browserlist is for making our file compatible with older browsers
Never ever upload node_modules in Github as they're heavy in size. package-lock.json has all the information to recreate node_modules
<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
Above 2 lines of code is not good for doing react as it is dependent upon cdn or we can say unpkg.com & the react version is dependent upon it. Whereas node_modules will be in our server. So we can import React in it which will be much easier to download.
Any doubt in React: Type that particular name with React after it and google search/ chatgpt search
If we've created something using HTML and have given an id. Entire content of this can be overwritten by react.create
Element


Lecture: 2
npx(execute using npm) parcel index.htm(entry point. It can be any file which we want to choose as entry point). This makes a development build & hosts it on the server.
Instant changes that we see on browser that we are doing in vscode file is because of parcel's HMR(Hot Module Replacement). It happens because of File Watcher Algorithm of Parcel written in C++. 
npx parcel build index.html is for production which parcel will build in dist folder. For production, entry point needs to be deleted from package.json as parcel will take from us & create itself. even if we delete dist folder it'll create it again making 3 important files index.html+css+js which parcel minified. It also bundles.
In dist index.06031e76 only last few lines are my code whereas all is imported React & ReactDOM. '.map' are helper files. 
node_modules are pushed from our system to VCS ---> From VCS to server --> From server(node_modules) to Website(build without node_module)
Parcel manages Dev & Production Build. It's superfast.
Most heavy thing on the browser is media
Parcel also does image optimisation alongwith JS Optimisation, Compression, & Minification. it does Caching while development. We can see the difference in loading parcel before and after parcel production installation. It takes less time after production. Compresses file like renaming it in index.06031e76
It also helps in being compatible with older version of browser
It adds Polyfills
Chrome gives http whereas something only works on https. Parcel gives the functionality of building our work on https on local dev machine
Whenever we'll change our build process(npx parcel index.html --https) it'll take time to load whereas for subsequent processess(npx parcel index.html) it won't because of caching in .parcel-cache.
Parchel-cache contains all the things with which parcel does all the things being a bundler.
Whenever we type npx-parcel index.html it hosts a faster development build on our server 
We should put parcel.cache in gitignore
Parcel also manages port number
Anything we put on server/ autogenerated can be put in .gitignore
Parcel uses Consistent Hashing Algorithm for caching
React is fast because of Virtual-DOM. Also itself it can't act fast as it is dependent upon bundlers & many more things.
Parcel possesses zero config as after installing it. It doesn't requires anything at all. All the dependencies are there.
Transitive Dependencies: Parcel depending upon it's dependencies/ packages or the dependencies/ packages depending upon their dependencies/ packages & so on.(Interview: We've our package managers which takes care of the transitive dependencies of our code)
Dependency Tree ---> React uses parcel. In a similar way parcel also uses something & it goes on. All of this makes the app performant.
Read Parcel Documentation
How many types of scripts are there ? 
https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script <--- Read about scripts here
React doesn't do Minification
In package.json mentioning last 2 versions in browserslist is last 2 versions of any browser parcel will support. We can also mention particular browser name say last 2 firefox versions. Sometimes it'll happen that even after mentioning the name of browser other browsers will also work that simply means the browser version we mentioned is same as of the unnamed browser version

  
Lecture: 3
devDependencies is for development environment whereas dependencies is for overall environment.
Polyfill: Code which is a replacement for a newer version fo code (babel does it with the help of browserslist). Say Array.map() <==> function myMap(). It happens because older version of browsers doesn't supports ES6.
Babel takes 1 piece of code & splits it into other piece of code.
git init initialises the repo with git. Then features like branches, collaborations, pull, push we can use
Larger scale production webpack is used. create react app uses webpack & babel
Tree Shaking: Property of parcel excluding unwanted things. Say babel imported libraries that r dependent upon 10 functions but in production we only used 2. So remaining 8 will be dismissed
A Performant Web Scalable App: React + Bundler <---Interview Question
"scripts": "start":"parcel index.html". We can replace the command npx parcel index.html by npm run start in package.json
Difference b/w npx & npm is npx is just used for executing without installing whereas npm is first installing then executing. npx <==> npm run. npx parcel index.html <==> npm run(npx) start(parcel index.html) 
Parcel & Babel won't itself know about removing console.log. We've to configure it with the help of a package named babel-plugin-tranform-remove-console
package.json contains the name & version of the module whereas actual code is there in node_modules. Putting a package doesn't mean it's used. We'll have to configure it.
On any npm package on web there's a way to install & use it.
.babelrc is a configuration file for babel. It's a better practice to delete dist folder before building it. Building is done 
Learn about script tags export: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script
Render = updating the DOM tree; Re-render = Change the whole DOM tree
Keys(passed as a prop) are important when passing children as if we'll not do it then re-render will happen making the app very slow. React tracks this key as a unique thing. Read recursing on children + keys from here https://legacy.reactjs.org/docs/reconciliation.html
JSX uses React.createElement creates an object. Object is then converted into HTML code which is put on the DOM.
JSX is a HTML like syntax inside JavaScript not HTML inside JavaScript
const heading2 = (
    <h1 id='title' key='h2' tab-index='1'>(HTML)       <h1 id='title' key='h2' tabIndex='1'>(JSX. Here we can see                                                 that tabIndex is a convention from JavaScript. Similarly class                                               in HTML and classname in JSX)
    Namaste React
    </h1>
)
Want to increase knowledge about babel: https://github.com/babel/babel/blob/main/CONTRIBUTING.md

const heading2 = (                                                             const heading1 = React.createElement(
<h1 id='title' key='h2' tab-index='1'>         =======Babel=======>           'h1',
Namaste React                                                                      {
</h1>                                                                                  id:'title',
                                                                                       key:'h1'
                                                                                   },
                                                                                   'Heading 1 for parcel') 
React.createElement makes an element which is same const to </h1> from above. So we'll be using this from now on.
transitive dependency versions are present in node_modules package_lock.json
const heading2 = (                                                             
<h1 id='title' key='h2' tab-index='1'>         
Namaste React                                                                      
</h1>
); JSX Expression: content inside (). And from const till ; React Element.
JSX is a syntax whereas babel is a dependency 
const heading2 = (                                                             
<h1 id='title' key='h2' tab-index='1'>         
Namaste React                                                                      
</h1>
);Adding an arrow function will make it a Functional Component(Function that returns JSX)
const heading2 = () =>
(                                                             
<h1 id='title' key='h2' tab-index='1'>         
Namaste React                                                                      
</h1>
);    
Component Composition = Passing Component into Component    
Babel needs to be installed imdividually. Best practice is with a bundler like Parcel, Webpack, VIte

Lecture: 4
Whenever we write JSX it gives us ReactElement(which is actually an Object) because of babel
There's no need for JSX, ES6, TypeScript & React for writing in React. We can even use React for a particular section in the FrontEnd using 'root'
const jsx = (
    <div>                  JSX won't render if <div> is not there as it should have only one parent. 
      <h1>JSX</h1>
      <h2>Second JSX</h2>
    </div>
            )
const jsx = (
<React.Fragment>           Whereas it'll run and will also keep away an extra <div> from the code.         
   <h1>JSX</h1>            <React.Fragment> is a component exported from React. It is like an empty tag.
   <h2>Second JSX</h2>
</React.Fragment>
            )
const jsx = (
<>                         <></> is shorthand for <React.Fragment></React.Fragment> which will act as parent.
   <h1>JSX</h1>
   <h2>Second JSX</h2>
</>
            )
<h1 style='background-color: red'>Hello</h1> <=== Inline Styling in HTML
const styleObj = {
    backgroundColour:'red',           <=== We'll not put semi-colon but comma as this is an object. 
}
const jsx = (
    <div style={styleObj}>            <=== This curly bracket will take an object which is javascript not jsx. 
       <h1>JSX</h1>             HTML like inline styling should be written outside. This is one way of writing it.
       <h1>Second JSX</h1>
    </div>
)
const jsx = (
    <div style={{                        <=== Second way of writing it.
         background-color: 'red',
    }}>                    
       <h1>JSX</h1>              
       <h1>Second JSX</h1>
    </div>
);
const jsx = (
    <div className='hello'               <==== Third way of doing it is putting classname then writing it in css
      style={{                        
        background-color: 'red',
    }}>                    
       <h1>JSX</h1>              
       <h1>Second JSX</h1>
    </div>
);
Fourth way of writing it is with Tailwind, Bootstrap, MaterialUI etc.
No issues in writing React.Fragment inside React.Fragment
Very Important Thing For Interviews: Config Driven UI's which is actually in layman terms called dynamic UI. Say we can have different restaurants with/ without offers, cuisines from intra/ inter city. To cater that, we need Config Driven UI.
Read about Optional Chaining in JavaScript
Whenever we're trying to render we write <RestaurantCard Restaurant={RestaurantList[0]} /> in which Restaurant is a function call which is a functional component here, {Restaurant=RestaurantList[0]} is the argument passed which is props here. When we pass props to a functional component then it is received as a parameter which can be used as any other variable. As we know in React we can write any piece of JS code within {}. {RestaurantList[0]} is a function call.
We can pass multiple props while rendering <RestaurantCard Restaurant={RestaurantList[0]} hello='world'/>. Here hello='world' is the 2nd prop.
Both 2 immediate examples are of destructuring
const RestaurantCard = ({restaurant}) => { We can also put {{restaurant}} in place of (props)
  return(
    <div className="card">
      <img src={'https://res.cloudinary.com/swiggy/image/upload/fl_lossy,f_auto,q_auto,w_508,h_320,c_fill/'
       + Restaurant.data?.cloudinaryImageId} /> As we can see props can be removed
      <h2>{Restaurant.data?.name}</h2> 
      <h3>{Restaurant.data?.cuisines.join(',')}</h3>
      <h4>{Restaurant.data?.avgRating} Stars</h4>
    </div>
  );
};
const RestaurantCard = {{restaurant}} => { 
    const {name, cuisines, cloudinaryImageId, avgRating} = Restaurant.data
  return(
    <div className="card">
      <img src={'https://res.cloudinary.com/swiggy/image/upload/fl_lossy,f_auto,q_auto,w_508,h_320,c_fill/'
       + cloudinaryImageId} /> As we can see props can be removed
      <h2>{name}</h2> 
      <h3>{cuisines.join(',')}</h3>
      <h4>{avgRating} Stars</h4>
    </div>
  );
};
Study difference b/w map & forEach, React Fibre, Reconciliation from React doc
React DOM is not actual DOM but a representation of DOM. HMR in parcel is diffreent then this as it's for the file whereas DOM is for Browser. React uses Diff algorithm which distinguishes b/w trees.
React 16 released React Fibre which a new Reconciliation Engine which is responsible for diff
const Body = () => {
  return (<div className='Restaurant-List'>
    {RestaurantList.map((Restaurant) => {
       return <RestaurantCard {...Restaurant.data} />
         })}      
  </div>)
};
const Body = () => {
  return (<div className='Restaurant-List'>
    {RestaurantList.map((Restaurant) => {
       return <RestaurantCard {...Restaurant.data} key='abc'/> It'll show error as 2 children can't have same keys. It should be unique
         return <RestaurantCard {...Restaurant.data} key={Restaurant.data.id}/> 
         })}      
  </div>)
}; 
We should never ever use index as the key. Read react for this. Also https://robinpokorny.com/blog/index-as-a-key-is-an-anti-pattern/
Read ===> https://legacy.reactjs.org/docs/faq-structure.html for React File Structure


Lecture: 4
export const Title = () => (
    //Below click on the logo & the page will be reloaded
    <a href='/'> 
    {/* Below is App logo */}
    <img className="logo" alt='logo' src='data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/' />
    </a>
  );
  Above needs to be imported as import {Title} from './components/Header'; this curly braces are for Named Import

  const HeaderComponent = () => {
    return (
      <div className='header'>
        <Title />
        <div>
          <ul className='nav-items'>
            <li>Home</li>
            <li>About</li>
            <li>Cotact</li>
            <li>Cart</li>
          </ul>
        </div>
      </div>
    );
  };
  export default HeaderComponent; <=== This is Default Import which needs to be imported as import HeaderComponent from './components/Header'; which is without curly braces
  Although we can import like this also import HeaderComponent, {Title} from './components/Header'; 
  './components/Header' './components/Header.js' both are fine 
Even if there are two named imports we can write like this {a, b}
We can also import named imports like ====> import * as Obj from './components/Header' and use like this as Obj.Title while rendering <Obj.Title />. * imports every component from that particular file so we render <Obj.Header />.

Thre's no issue in writing extensions like .js/.jsx. Both are same. But sometimes if we are using an external library then it can break as it tracks these kind of files.

Hooks is a JS Function
const [searchText] = useState(); useState Hooks returns an array in which variable name(searchText) is the 1st element. Creates Local State Variable, here searchText. Whereas normal JS variables are crreated using let, const, var
Below block of code won't run in React whereas in HTML it'll run. 
const searchText = 'KFC'; //local variable
    return (
    <>
    <div className='search-container'>
    <input
      type='text'
      className='search-input'
      placeholder='Search'
      value={searchText}
      onChange={(e)=>{
        searchText = e.target.value;
      }}/>
Above code: We can't change values for local variable(searchText, in this case) created in React with onChange function. That we've to do with the help of Hooks which will give a function to update the local variable. 